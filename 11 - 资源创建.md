# 11 - 资源创建

## ......

## 图像布局

图像存储在内存中与实现相关的不透明布局中。每个布局对使用该布局的图像子资源所支持的操作类型都有限制。任何时候，内存中代表图像子资源的数据都存在于特定的布局中，该布局由最近对该图像子资源执行的布局转换决定。应用程序可控制每个图像子资源使用的布局，并可将图像子资源从一个布局过渡到另一个布局。转换可以通过图像内存屏障实现，包括作为 vkCmdPipelineBarrier 或 vkCmdWaitEvents 命令缓冲区命令的一部分（请参阅图像内存屏障），或作为渲染传递中子传递依赖关系的一部分（请参阅 VkSubpassDependency）。

图像布局是每一个图像的子资源（Image layout is per-image subresource.）。同一图像的不同图像子资源可以同时处于不同的布局中，但如果启用了 separateDepthStencilLayouts 功能，给定图像子资源的深度和模版方面只能处于不同的布局中。

> [!note]
> 每种布局都可以为图像内存的特定用途提供最佳性能。例如，布局为 VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL 的图像在用作彩色附件时可提供最佳性能，但在用于传输命令时则不受支持。
> 当图像子资源用于多种操作时，应用程序可将图像子资源从一种布局过渡到另一种布局，以获得最佳性能。初始化后，应用程序无需使用一般布局以外的任何布局，但这可能会在某些实现中产生次优性能。

创建时，图像的所有图像子资源初始化为相同的布局，该布局由 VkImageCreateInfo::initialLayout 成员选择。初始布局必须是 VK_IMAGE_LAYOUT_UNDEFINED 或 VK_IMAGE_LAYOUT_PREINITIALIZED。
如果它是 VK_IMAGE_LAYOUT_PREINITIALIZED，那么图像数据可以在使用此布局时由主机预初始化，从此布局过渡时将保留这些数据。
如果是 VK_IMAGE_LAYOUT_UNDEFINED，那么数据的内容将被视为未定义的，并且不保证从该布局过渡时会保留这些数据。
对于这两种初始布局，任何图像子资源都必须在被设备访问之前过渡到另一种布局。

主机对图像内存的访问仅适用于线性图像以及当前处于 VK_IMAGE_LAYOUT_PREINITIALIZED 或 VK_IMAGE_LAYOUT_GENERAL 布局中的图像子资源。为线性图像调用 vkGetImageSubresourceLayout 会返回对上述任一图像布局有效的子资源布局映射。

图像布局集包括

```cpp
// Provided by VK_VERSION_1_0
typedef enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
  // Provided by VK_VERSION_1_1
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
  // Provided by VK_VERSION_1_1
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
  // Provided by VK_VERSION_1_2
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
  // Provided by VK_VERSION_1_2
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
  // Provided by VK_VERSION_1_2
    VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
  // Provided by VK_VERSION_1_2
    VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
  // Provided by VK_VERSION_1_3
    VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000,
  // Provided by VK_VERSION_1_3
    VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001,
} VkImageLayout;
```

每个布局支持的设备访问类型是[Resource Creation :: Vulkan Documentation Project](https://docs.vulkan.org/spec/latest/chapters/resources.html#resources-image-layouts)

- VK_IMAGE_LAYOUT_UNDEFINED 表示布局未知。图像内存无法过渡到此布局。此布局可用作 VkImageCreateInfo 的 initialLayout 成员。在布局转换中，可以使用此布局代替当前图像布局，但这样做会导致图像内存的内容未定义。
- VK_IMAGE_LAYOUT_PREINITIALIZED 表示图像内存处于已定义的布局中，可以被数据填充，但驱动程序尚未对其进行初始化。图像内存不能过渡到此布局中。此布局可用作 VkImageCreateInfo 的 initialLayout 成员。该布局的目的是用作由主机写入内容的图像的初始布局，因此可以立即将数据写入内存，而无需首先执行布局转换。目前，VK_IMAGE_LAYOUT_PREINITIALIZED 仅对线性图像有用，因为 VK_IMAGE_TILING_OPTIMAL 图像没有定义标准布局。

每个图像子资源的布局并不是图像子资源本身的一种状态，而是内存中数据组织方式的一种属性，因此，对于 API 中访问图像的每种机制，应用程序都必须指定一个参数或结构成员，指明在访问图像时，图像子资源处于哪种图像布局。对于传输命令，这是命令的一个参数（请参阅 "清除命令 "和 "复制命令"）。作为帧缓冲区附件使用时，这是 VkRenderPassCreateInfo 子结构中的一个成员（请参阅 "渲染传递"）。要在描述符集中使用，这是 VkDescriptorImageInfo 结构中的一个成员（请参阅描述符集更新）。

### 图像布局匹配规则

在任何队列上执行任何访问图像的命令缓冲区命令时，被访问的图像子资源的布局都必须与通过控制这些访问的 API 指定的布局完全匹配，除非是通过仅引用图像单个方面的描述符来访问具有深度/模板格式的图像，在这种情况下适用以下放宽的匹配规则：

- 仅指向深度/模版图像的深度方面的描述符只需在深度方面的图像布局中匹配，因此 VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL 和 VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL 被视为匹配。
- 只涉及深度/钢网图像的钢网方面的描述符只需在钢网方面的图像布局中匹配，因此 VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL 和 VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL 被认为是匹配的。

在对图像子资源执行布局转换时，旧布局值必须等于图像子资源的当前布局（在执行转换时），否则就是 VK_IMAGE_LAYOUT_UNDEFINED（这意味着不需要保留图像子资源的内容）。过渡中使用的新布局不能是 VK_IMAGE_LAYOUT_UNDEFINED 或 VK_IMAGE_LAYOUT_PREINITIALIZED。

使用 VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT 创建的深度/模版图像的每个图像子资源的图像布局取决于最后用于将图像子资源渲染为深度/模版附件的采样位置，因此无论何时发生图像子资源的布局转换，应用程序都必须提供最后用于渲染给定图像子资源的相同采样位置，否则图像子资源的深度方面的内容将变得未定义。

此外，从深度/模版附件读取深度时，如果引用的是用 VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT 创建的深度/模版图像的图像子资源范围，且所使用的采样位置与上次用于向同一图像子资源范围的图像子资源执行深度写入的采样位置不同，则会返回未定义的值。

同样，对深度/模版附件的深度写入，如果引用的是用 VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT 创建的深度/模版图像的图像子资源范围，且使用的采样位置与上次用于对同一图像子资源范围的图像子资源执行深度写入的采样位置不同，则这些图像子资源的深度方面的内容将无法定义。

## 图像视图

管线着色器不会直接访问图像对象来读取或写入图像数据。相反，代表图像子资源连续内存范围并包含附加元数据的图像视图可用于此目的。视图必须在兼容类型的图像上创建，并且必须代表图像子资源的有效子集。

<details>
<summary>ImageView API</summary>
图像视图由 VkImageView 句柄表示：

```cpp
// Provided by VK_VERSION_1_0
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImageView)
```

VK_REMAINING_ARRAY_LAYERS 是一个特殊的常量值，用于图像视图，表示图像中基底层之后的所有剩余数组层都应包含在视图中。

```cpp
#define VK_REMAINING_ARRAY_LAYERS         (~0U)
```

VK_REMAINING_MIP_LEVELS 是一个特殊的常量值，用于图像视图，表示图像中在基本级别之后的所有剩余 mipmap 级别都应包含在视图中。

```cpp
#define VK_REMAINING_MIP_LEVELS           (~0U)
```

可创建的图像视图类型有

```cpp
// Provided by VK_VERSION_1_0
typedef enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
} VkImageViewType;
```

创建图像视图，调用：

```cpp
// Provided by VK_VERSION_1_0
VkResult vkCreateImageView(
    VkDevice                                    device,
    const VkImageViewCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkImageView*                                pView);
```

- device 是创建图像视图的逻辑设备。
- pCreateInfo 是指向 VkImageViewCreateInfo 结构的指针，该结构包含用于创建图像视图的参数。
- pAllocator 控制主机内存分配，详见内存分配章节。
- pView 是指向 VkImageView 句柄的指针，生成的图像视图对象将返回到该句柄中。

VkImageViewCreateInfo 结构定义如下：

```cpp
// Provided by VK_VERSION_1_0
typedef struct VkImageViewCreateInfo {
    VkStructureType            sType;
    const void*                pNext;
    VkImageViewCreateFlags     flags;
    VkImage                    image;
    VkImageViewType            viewType;
    VkFormat                   format;
    VkComponentMapping         components;
    VkImageSubresourceRange    subresourceRange;
} VkImageViewCreateInfo;
```

- sType 是标识此结构的 VkStructureType 值。
- pNext 是 NULL 或指向扩展此结构的结构的指针。
- flags 是 VkImageViewCreateFlagBits 的位掩码，用于指定图像视图的其他参数。
- image 是将在其上创建视图的 VkImage。
- viewType 是一个 VkImageViewType 值，指定图像视图的类型。
- format 是一个 VkFormat，指定用于解释图像像素块的格式和类型。
- components 是一个 VkComponentMapping 结构，用于指定颜色分量（或深度分量或模板分量转换为颜色分量后的分量）的重新映射。
- subresourceRange 是一个 VkImageSubresourceRange 结构，用于选择视图可访问的 mipmap 层和数组层集合。

视图继承了部分图像创建参数。特别是，图像视图创建会继承隐式参数 usage，该参数指定了图像视图允许使用的用途，默认情况下，在图像创建时使用 VkImageCreateInfo 中指定的相应用途参数值。可以通过在 pNext 链中添加 VkImageViewUsageCreateInfo 结构来覆盖隐式用法，但视图用法必须是图像用法的子集。如果图像具有深度模版格式，并且是通过 VkImageCreateInfo 的 pNext 链中包含的 VkImageStencilUsageCreateInfo 结构创建的，则会根据提供的 subresource.aspectMask 计算用法（usage）：

- 如果 aspectMask 只包括 VK_IMAGE_ASPECT_STENCIL_BIT，则隐式用法（usage）等于 VkImageStencilUsageCreateInfo::stencilUsage。
- 如果 aspectMask 只包含 VK_IMAGE_ASPECT_DEPTH_BIT，隐式用法（usage）等于 VkImageCreateInfo::usage。
- 如果 aspectMask 中包含两个方面，隐式用法（usage）等于 VkImageCreateInfo::usage 和 VkImageStencilUsageCreateInfo::stencilUsage 的交集。

如果图像是三维图像，可通过在 pNext 链中添加 VkImageViewSlicedCreateInfoEXT 将其 Z 范围限制为子集。

如果图像是使用 VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT 标记创建的，且图像格式不是多平面的，则格式可以与图像格式不同，但如果图像是在没有使用 VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT 标记的情况下创建的，且两者不相等，则必须兼容。图像格式兼容性在格式兼容性类部分进行了定义。无论采用何种格式，兼容格式的视图都将具有相同的像素坐标和内存位置映射，只有位模式的解释会发生变化。

如果图像是以多平面格式创建的，且图像视图的宽高比掩码（aspectMask）为 VK_IMAGE_ASPECT_PLANE_0_BIT、VK_IMAGE_ASPECT_PLANE_1_BIT 或 VK_IMAGE_ASPECT_PLANE_2_BIT，则视图的宽高比掩码在用作帧缓冲附件时将被视为等同于 VK_IMAGE_ASPECT_COLOR_BIT。

> [!note]
> 用于一种视图格式的值在通过不同格式写入或读取时可能无法完全保留。例如，通过浮点格式视图写入或读取的整数值，如果其位模式恰好是浮点反规范或 NaN，则可能会被刷新或规范化。同样，通过带符号的归一化格式写入的数值，如果其位模式正好等于-2^b，则可以按照从归一化定点到浮点的转换中的描述，将其改为-2^b + 1。

如果图像是使用 VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT 标志创建的，格式必须与上述图像格式兼容；或者必须是未压缩格式，在这种情况下，格式必须与图像格式的尺寸兼容。在这种情况下，生成的图像视图的像素尺寸等于所选 mip 级别的尺寸除以压缩后的像素块尺寸，然后四舍五入。

VkComponentMapping 组件成员描述了从图像组件到着色器图像指令返回的矢量组件的重映射。对于存储图像描述符、输入附件描述符、帧缓冲器附件以及任何与组合图像采样器一起使用的 VkImageView（该采样器可启用采样器 $Y'C_B C_R$ 转换），该重新映射都必须是标识转换。

如果图像视图要与支持采样器 $Y'C_B C_R$ 转换的采样器一起使用，则必须在 VkImageViewCreateInfo 的 pNext 链中包含的 VkSamplerYcbcrConversionInfo 中向 vkCreateImageView 传递一个与创建采样器所用的 VkSamplerYcbcrConversion 类型相同的定义对象。相反，如果向 vkCreateImageView 传递了 VkSamplerYcbcrConversion 对象，则在对图像进行采样时必须使用定义相同的 VkSamplerYcbcrConversion 对象。

如果图像具有多平面格式，subresourceRange.aspectMask 为 VK_IMAGE_ASPECT_COLOR_BIT，且用途包括 VK_IMAGE_USAGE_SAMPLED_BIT，则格式必须与图像格式相同，且与图像视图一起使用的采样器必须启用采样器 $Y'C_B C_R$ 转换。

在视频编码操作中使用此类图像时，采样器 $Y'C_B C_R$ 转换不起作用。

如果图像是使用 VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT 创建的，且图像具有多平面格式，并且 subresourceRange.aspectMask 为 VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT 时，采样器 $Y'C_B C_R$ 转换将不会生效。 aspectMask 为 VK_IMAGE_ASPECT_PLANE_0_BIT、VK_IMAGE_ASPECT_PLANE_1_BIT 或 VK_IMAGE_ASPECT_PLANE_2_BIT，格式必须与图像的相应平面兼容，并且与图像视图一起使用的采样器不能启用采样器 $Y'C_B C_R$ 转换。单平面图像视图的宽度和高度必须根据多平面图像的尺寸，按照所列的平面兼容性方式导出。

图像平面的任何视图都将具有与色彩方面的组件所使用的相同的纹理元（texel）坐标和内存位置之间的映射，但须遵守纹理元（texel）坐标与低分辨率平面之间的相关公式（如色度重建中所述）。也就是说，如果 R 平面或 B 平面的分辨率相对于多平面图像的 G 平面有所降低，则图像视图将使用降低分辨率平面的（u_plane, v_plane）非规范化坐标进行操作，这些坐标所访问的内存位置与色彩方面的（u_color, v_color）非规范化坐标相同，而色彩方面的色度重建操作将在相同的（u_plane, v_plane）或（i_plane, j_plane）坐标上进行。

>[!note] Texel 纹理元
>![](https://img-blog.csdn.net/20170315165913210)

表 1. 图像类型和图像视图类型兼容性要求
![](pic/Pasted%20image%2020240703113228.png)

可以在 VkImageViewCreateInfo::flags 中设置的位有

```cpp
// Provided by VK_VERSION_1_0
typedef enum VkImageViewCreateFlagBits {
  // Provided by VK_EXT_fragment_density_map
    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x00000001,
  // Provided by VK_EXT_descriptor_buffer
    VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x00000004,
  // Provided by VK_EXT_fragment_density_map2
    VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 0x00000002,
} VkImageViewCreateFlagBits;
```

- VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT 指定在 VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT 期间由设备读取片段密度映射。
- VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT 指定片段密度贴图将在 vkEndCommandBuffer 期间由主机读取，用于记录渲染传递的主命令缓冲区。
- VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT 指定图像视图可在捕获和重放时与描述符缓冲区一起使用（例如用于轨迹捕获和重放），详情请参阅 VkOpaqueCaptureDescriptorDataCreateInfoEXT。

```cpp
// Provided by VK_VERSION_1_0
typedef VkFlags VkImageViewCreateFlags;
```

VkImageViewCreateFlags 是一种位掩码类型，用于设置零个或多个 VkImageViewCreateFlagBits 的掩码。

通过在 VkImageViewCreateInfo 的 pNext 链中添加一个 VkImageViewUsageCreateInfo 结构，创建的图像视图的使用集可与父图像的使用标志相比受到限制。

</details>
